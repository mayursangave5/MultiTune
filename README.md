# SyncAudio - High-Fidelity Synchronized Audio Playback

An Android application that enables precise, synchronized audio playback across multiple devices. One device acts as a **Host**, serving audio and syncing clocks, while other devices join as **Clients** to play music in perfect unison.

## üöÄ Key Features

*   **Multi-Device Synchronization**: Achieves millisecond-level playback synchronization using a custom NTP-like clock sync algorithm and UDP broadcast triggers.
*   **High-Fidelity Audio Engine**:
    *   **RAM-First Architecture**: Loads entire audio files into memory to eliminate disk I/O latency and stutter.
    *   **Native AudioTrack**: Bypasses high-level players (MediaPlayer/ExoPlayer) for direct low-latency hardware control.
    *   **Universal Format Support**: Uses `MediaCodec` to decode MP3, AAC, WAV, and FLAC into raw 16-bit PCM data for pristine playback.
    *   **Jitter-Free Playback**: Runs on a dedicated high-priority thread (`URGENT_AUDIO`) with a custom blocking write loop and spin-wait triggering.
*   **Instant Connectivity**:
    *   **HTTP Server**: Embedded Ktor server on the Host to serve audio and time signals.
    *   **QR Code Pairing**: Clients scan a QR code generated by the Host for instant IP configuration.
    *   **UDP Signaling**: Lightweight UDP packets for "READY" status and precise "PLAY_AT" commands.

## üõ†Ô∏è Tech Stack

*   **Language**: Kotlin
*   **UI**: Jetpack Compose (Material 3)
*   **Networking**:
    *   **Host**: Ktor (Netty/CIO) for HTTP & UDP.
    *   **Client**: OkHttp for downloads & API calls.
*   **Audio**: Android `AudioTrack` API, `MediaExtractor`, `MediaCodec`.
*   **Camera**: CameraX + ML Kit (for QR scanning).
*   **Min SDK**: 26 (Android 8.0)

## üèóÔ∏è Architecture

### 1. The Host
*   Starts a local HTTP server (port 8080).
*   Loads the selected audio file into RAM.
*   Displays a QR code with its local IP address.
*   Broadcasts a NTP reference time.
*   When "Start Playback" is pressed:
    1.  Calculates a future timestamp (e.g., `now + 3000ms`).
    2.  Broadcasts a `PLAY_AT|timestamp` UDP packet to all clients.
    3.  Begins its own local playback loop to start exactly at that timestamp.

### 2. The Client
*   Scans QR code to get Host IP.
*   Downloads the audio file via HTTP into a RAM buffer.
*   Performs clock synchronization:
    *   Exchanges multiple time packets with the Host.
    *   Calculates round-trip delay (RTT) and clock offset using a median filter.
*   Enters "Listening" mode on a UDP port.
*   Upon receiving `PLAY_AT|timestamp`:
    1.  Adjusts the target timestamp using the calculated clock offset.
    2.  Spins up a high-priority thread.
    3.  Pre-fills the audio buffer.
    4.  Waits (sleep + spin) until the exact target millisecond.
    5.  Ignites playback.

## üì¶ Installation

1.  Clone the repository.
2.  Open in Android Studio Ladybug (or newer).
3.  Sync Gradle project.
4.  Build and Run on two or more Android devices connected to the **same Wi-Fi network**.

## üìù Usage

1.  **Device A (Host)**:
    *   Select "I am the Host".
    *   Grant permissions.
    *   Tap "Select Song" and pick an audio file.
    *   Wait for clients to connect (they will appear in the list).
    *   Tap "Start Synced Playback".

2.  **Device B (Client)**:
    *   Select "I am a Client".
    *   Grant permissions.
    *   Scan the QR code displayed on the Host.
    *   Wait for "Download Complete" and "Ready" status.
    *   Enjoy the music!

## üîß Engineering Details

This project strictly follows a "Lossless Low-Latency" engineering prompt:
*   **No Disk I/O during playback**: Audio is decoded to `ByteArray` using `AudioDecoder` before playback starts.
*   **Buffer Priming**: The `AudioTrack` buffer is pre-filled ensuring 0ms start-up delay when `play()` is called.
*   **Thread Safety**: `@Synchronized` locks prevent recursive playback triggers from UDP packet bursts.
